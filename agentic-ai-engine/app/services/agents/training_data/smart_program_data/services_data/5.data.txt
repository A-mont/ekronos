
// services.rs for DEX program

#![no_std]

use extended_vft_client::vft::io as vft_io;
use sails_rs::calls::ActionIo;
use sails_rs::{
    cell::RefCell,
    collections::HashMap,
    gstd::{exec, msg},
    prelude::*,
};

const MINIMUM_LIQUIDITY: u128 = 1_000;

// ================== STATE ==================

#[derive(Clone, Debug)]
pub struct Storage {
    pub admin: ActorId,
    pub reserve_a: U256,
    pub reserve_b: U256,
    pub total_liquidity: U256,
    pub liquidity_providers: HashMap<ActorId, U256>,
    pub token_a: ActorId,
    pub token_b: ActorId,
    pub k_last: U256,
    pub dns_info: Option<(ActorId, String)>,
    pub liquidity_action_gas: u64,
    pub swap_status: SwapStatus,
}

// ================== SERVICE ==================

pub struct DexService<'a> {
    state: &'a RefCell<Storage>,
}

impl<'a> DexService<'a> {
    pub fn new(state: &'a RefCell<Storage>) -> Self {
        Self { state }
    }

    fn get(&self) -> core::cell::Ref<'_, Storage> {
        self.state.borrow()
    }

    fn get_mut(&self) -> core::cell::RefMut<'_, Storage> {
        self.state.borrow_mut()
    }
}

#[service(events = Event)]
impl<'a> DexService<'a> {
    #[export]
    pub async fn add_liquidity(&mut self, amount_a: U256, amount_b: U256) -> bool {
        let sender = msg::source();
        let program_id = exec::program_id();
        let mut storage = self.get_mut();

        assert_eq!(storage.swap_status, SwapStatus::Ready, "Swap paused");

        let first_time = storage.reserve_a.is_zero() && storage.reserve_b.is_zero();

        let liquidity = if first_time {
            let liq = (amount_a * amount_b).integer_sqrt();
            assert!(liq >= MINIMUM_LIQUIDITY.into(), "Liquidity too low");
            liq
        } else {
            U256::min(
                (amount_a * storage.total_liquidity) / storage.reserve_a,
                (amount_b * storage.total_liquidity) / storage.reserve_b,
            )
        };

        storage.swap_status = SwapStatus::Paused;
        drop(storage); // ðŸ”´ importante antes del await

        let req_a = vft_io::TransferFrom::encode_call(sender, program_id, amount_a);
        msg::send_bytes_with_gas_for_reply(storage.token_a, req_a, 5_000_000_000, 0, 0)
            .unwrap()
            .await
            .unwrap();

        let req_b = vft_io::TransferFrom::encode_call(sender, program_id, amount_b);
        msg::send_bytes_with_gas_for_reply(storage.token_b, req_b, 5_000_000_000, 0, 0)
            .unwrap()
            .await
            .unwrap();

        let mut storage = self.get_mut();
        storage.reserve_a += amount_a;
        storage.reserve_b += amount_b;
        storage.total_liquidity += liquidity;
        *storage.liquidity_providers.entry(sender).or_default() += liquidity;
        storage.k_last = storage.reserve_a * storage.reserve_b;
        storage.swap_status = SwapStatus::Ready;

        self.emit_event(Event::AddedLiquidity {
            sender,
            amount_a,
            amount_b,
            liquidity,
        }).unwrap();

        true
    }

    #[export]
    pub fn reserve_a(&self) -> U256 {
        self.get().reserve_a
    }

    #[export]
    pub fn reserve_b(&self) -> U256 {
        self.get().reserve_b
    }
}
